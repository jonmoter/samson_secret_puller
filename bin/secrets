#!/usr/bin/env ruby
require 'vault'

raise "vault address not found" unless vault_address = ENV.fetch("VAULT_ADDR",false)

Vault.configure do |config|
  config.ssl_pem_file = '/vault-auth/pem' #this is the secrets volume insde the k8s cluster
  config.ssl_verify = false #FIXME: make this ENV driven
  config.address = vault_address

  # Timeout the connection after a certain amount of time (seconds)
  config.timeout = 5

  # It is also possible to have finer-grained controls over the timeouts, these
  # may also be read as environment variables
  config.ssl_timeout  = 3
  config.open_timeout = 3
  config.read_timeout = 2
end


class Secrets

  SECRET_KEY_PATH = "/secretkeys/annotations".freeze
  ENCODINGS = {"/": "%2F"}
  CERT_AUTH_PATH =  '/v1/auth/cert/login'.freeze
  PEM = File.read(Vault.ssl_pem_file)
  DEFAULT_OPTIONS = {
    use_ssl: true,
    verify_mode: 0,
    cert: OpenSSL::X509::Certificate.new(PEM),
    key: OpenSSL::PKey::RSA.new(PEM)
  }

  # to get a token from the api using the cert
  def initialize(http = nil)
    uri = URI.parse(Vault.address)
      @http = Net::HTTP.start(uri.host, uri.port, DEFAULT_OPTIONS)
    response = @http.request(Net::HTTP::Post.new(CERT_AUTH_PATH))
    if (response.code.to_i == 200)
      Vault.token = JSON.parse(response.body).delete("auth")["client_token"]
    else
      raise "Missing Token"
    end
    # make sure that we have secret keys
    raise "#{SECRET_KEY_PATH} not found" unless File.exists?(SECRET_KEY_PATH)
    @secret_keys = []
    IO.readlines(SECRET_KEY_PATH).each do |line|
      if line =~ /^secret\/.*$/
        key = line.split("=").first.split("/").last
        value = line.split("=").last.chomp.gsub('"','')
        @secret_keys << {"#{key}": value}
      end
    end
    raise "#{SECRET_KEY_PATH} contains no secrets" unless @secret_keys.count > 0
  end

  def process
    @secret_keys.each do |secret|
    secret.each do |name, path|
      contents = read(path)
      File.open('/secrets/' + name.to_s, 'w+') { |f| f.puts contents }
      end
    end
  end

  private

  def read(key)
    result = Vault.logical.read(vault_path(key))
    false if result.nil?
    result = result.to_h
    result = result.merge(result.delete(:data))
    result.delete(:vault)
  end

  def vault_path(key)
    "secret/" + key
  end

  def convert_path(string, direction)
    string = string.dup
    if direction == :decode
      ENCODINGS.each { |k, v| string.gsub!(v.to_s, k.to_s) }
    elsif direction == :encode
      ENCODINGS.each { |k, v| string.gsub!(k.to_s, v.to_s) }
    else
      raise ArgumentError.new("direction is required")
    end
    string
  end
end

client = Secrets.new()

loop do
  client.process
  sleep 60
end
